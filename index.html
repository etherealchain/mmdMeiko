<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js MMD</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="mmd.css">
	</head>

	<body>
		<div id="info">
		<a href="https://github.com/etherealchain/mmdMeiko" target="_blank">Disclaimer</a><br />
		</div>
		<div id="loader">
			<div id="spinner"></div>
			<div id="progressGray">
				<div id="progressBlue">0%</div>
			</div>
			</div>
		</div>
		<script id="bloomVS" type="x-shader/x-vertex">
			varying vec2 vUv;
			void main{
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>
		<script id="bloomFS" type="x-shader/x-vertex">
			uniform sampler2D tDiffuse;
			varying vec2 vUv;
			
			void main{
				vec4 texel = texture2D( tDiffuse, vUv );
			}
		</script>
		<script id="lightVS" type="x-shader/x-vertex">
			uniform vec3 scale;
			varying vec2 v_uv;
                
			void main()
			{
				v_uv = uv;
				float rotation = 0.0;

				vec3 alignedPosition = vec3(position.x * scale.x, position.y * scale.y, position.z*scale.z);

				vec2 pos = alignedPosition.xy;

				vec2 rotatedPosition;
				rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
				rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

				vec4 finalPosition;

				finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
				finalPosition.xy += rotatedPosition;
				finalPosition = projectionMatrix * finalPosition;
				gl_Position =  finalPosition;
			}
		</script>
		<script id="lightFS" type="x-shader/x-fragment">
			varying vec2 v_uv;
			uniform vec3 color;
			void main( void ) {

				vec2 uv = v_uv;
				// Zooms out by a factor of 2.0
				uv *= 2.0;
				// Shifts every axis by -1.0
				uv -= 1.0;
				
				// size of circle in terms of uv 
				float circleRadius = 1.0; 
				
				float smoothWidth = 0.01;
				float alpha = smoothstep(circleRadius - smoothWidth, circleRadius, length(uv));
				gl_FragColor = vec4( color , 1.0-alpha );
			}
		</script>
		<script id="floorVS" type="x-shader/x-vertex">
			#define PHONG
			varying vec3 vViewPosition;
			#ifndef FLAT_SHADED
			varying vec3 vNormal;
			#endif

			#include <common>
			#include <uv_pars_vertex>
			#include <uv2_pars_vertex>
			#include <displacementmap_pars_vertex>
			#include <envmap_pars_vertex>
			#include <color_pars_vertex>
			#include <fog_pars_vertex>
			#include <morphtarget_pars_vertex>
			#include <skinning_pars_vertex>
			#include <shadowmap_pars_vertex>
			#include <logdepthbuf_pars_vertex>
			#include <clipping_planes_pars_vertex>

			uniform mat4 textureMatrix;
			varying vec4 mirrorCoord;

			void main() {
				#include <uv_vertex>
				#include <uv2_vertex>
				#include <color_vertex>
				#include <beginnormal_vertex>
				#include <morphnormal_vertex>
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#include <defaultnormal_vertex>

				#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
					vNormal = normalize( transformedNormal );
				#endif

				#include <begin_vertex>
				#include <displacementmap_vertex>
				#include <morphtarget_vertex>
				#include <skinning_vertex>
				#include <project_vertex>
				#include <logdepthbuf_vertex>
				#include <clipping_planes_vertex>

				vViewPosition = - mvPosition.xyz;
				
				#include <worldpos_vertex>
				#include <envmap_vertex>
				#include <shadowmap_vertex>
				#include <fog_vertex>

				mirrorCoord = textureMatrix * worldPosition;
			}
		</script>
		<script id="floorFS" type="x-shader/x-fragment">
			#define PHONG
			uniform vec3 diffuse;
			uniform vec3 emissive;
			uniform vec3 specular;
			uniform float shininess;
			uniform float opacity;
			#include <common>
			#include <packing>
			#include <color_pars_fragment>
			#include <uv_pars_fragment>
			#include <uv2_pars_fragment>
			#include <map_pars_fragment>
			#include <alphamap_pars_fragment>
			#include <aomap_pars_fragment>
			#include <lightmap_pars_fragment>
			#include <emissivemap_pars_fragment>
			#include <envmap_pars_fragment>
			#include <gradientmap_pars_fragment>
			#include <fog_pars_fragment>
			#include <bsdfs>
			#include <lights_pars>
			#include <lights_phong_pars_fragment>
			#include <shadowmap_pars_fragment>
			#include <bumpmap_pars_fragment>
			#include <normalmap_pars_fragment>
			#include <specularmap_pars_fragment>
			#include <logdepthbuf_pars_fragment>
			#include <clipping_planes_pars_fragment>

			uniform sampler2D mirrorSampler;
			varying vec4 mirrorCoord;

			float blendOverlay(float base, float blend) {
				return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
			}

			void main() {
				#include <clipping_planes_fragment>
				vec4 diffuseColor = vec4( diffuse, opacity );
				ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
				vec3 totalEmissiveRadiance = emissive;

				#include <logdepthbuf_fragment>
				#include <map_fragment>
				#include <color_fragment>
				#include <alphamap_fragment>
				#include <alphatest_fragment>
				#include <specularmap_fragment>
				#include <normal_flip>
				#include <normal_fragment>
				#include <emissivemap_fragment>

				// accumulation
				#include <lights_phong_fragment>
				#include <lights_template>

				// modulation
				#include <aomap_fragment>
				
				vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
				#include <envmap_fragment>

				vec4 mirrorValue = texture2DProj(mirrorSampler, mirrorCoord);
				vec4 lightColor = vec4( outgoingLight, diffuseColor.a );
				gl_FragColor = vec4(blendOverlay(lightColor.r, mirrorValue.r), blendOverlay(lightColor.g, mirrorValue.g), blendOverlay(lightColor.b, mirrorValue.b), 1.0);

				#include <premultiplied_alpha_fragment>
				#include <tonemapping_fragment>
				#include <encodings_fragment>
				#include <fog_fragment>
			}
		</script>

		<script src="lib/three.min.js"></script>

		<script src="lib/mmdparser.min.js"></script>
		<script src="lib/ammo.js"></script>

		<script src="lib/TGALoader.js"></script>
		<script src="lib/MMDLoader.js"></script>
		<script src="lib/OutlineEffect.js"></script>
		<script src="lib/CCDIKSolver.js"></script>
		<script src="lib/MMDPhysics.js"></script>

		<script src="lib/CopyShader.js"></script>
		<script src="lib/EffectComposer.js"></script>
		<script src="lib/RenderPass.js"></script>
    	<script src="lib/ShaderPass.js"></script>
		<script src="lib/MaskPass.js"></script>
		<script src="bloom.js"></script>

		<script src="lib/OrbitControls.js"></script>

		<script src="lib/Detector.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/dat.gui.min.js"></script>
		<script src="lib/Tween.js"></script>

		<script src="reflection.js"></script>
		<script src="mmd.js"></script>
		
	</body>
</html>
